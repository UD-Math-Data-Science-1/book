# Representation of data

::: {.content-visible unless-format="pdf"}
{{< include _macros.qmd >}}
:::

First we have to discuss how to represent data, both abstractly and in Python.

## Quantitative data

:::{#def-data-quantitative}
A **quantitative** value is one that is numerical and supports meaningful comparison and arithmetic operations.
:::

 Quantitative data is further divided into **continuous** and **discrete** types. The difference is the same as between real numbers and integers.

::::{#exm-data-quantitative chapter=1 description="Quantitative data" type=‚úçÔ∏è}
Some continuous quantitative data sources:

* Temperature at noon at a given airport
* Your height
* Voltage across the terminals of a battery

Examples of discrete quantitative data:

* The number of shoes you own
* Number of people at a restaurant table
* Score on an exam
::::

:::{.column-margin}
{{< video https://www.dropbox.com/s/l9fs3fa43hup08l/Example1_1.mp4?raw=1 >}}
:::

:::{.callout-note}
Sometimes there may be room for interpretation or context. For example, the retail price of a gallon of milk might be regarded as discrete data, since it technically represents a whole number of pennies. But in finance, transactions are regularly computed to much higher precision, so it might make more sense to interpret prices as continuous values. As a rule of thumb, if there are many possible values, or the values are the result of a measurement, the continuous interpretation is usually more appropriate.
:::

::::{.callout-caution}
Not all numerical values represent truly quantitative data. ZIP codes (postal codes) in the U.S. are 5-digit numbers, and while there is some logic to how they were assigned, there is no clearly meaningful interpretation of averaging them, for instance.
::::

For both continuous and discrete quantities, it makes sense to order different values, compute averages of them, etc. (However, averages of discrete quantities are continuous.)

Mathematically, the real and integer number sets are infinite, but computers are finite machines. Integers are represented exactly within some range that is determined by how many binary bits are dedicated. The computational analog of real numbers are **floating-point numbers**, or more simply, **floats**. These are bounded in range as well as discretized. The details are complicated, but essentially, the floating-point numbers have about 16 significant decimal digits by default‚Äîwhich is virtually always far more precision than real data offers.

:::{.column-margin}
<div style="max-width:304px"><div style="position:relative;padding-bottom:75.986842105263%"><iframe id="kaltura_player" src="https://cdnapisec.kaltura.com/p/2358381/sp/235838100/embedIframeJs/uiconf_id/43030021/partner_id/2358381?iframeembed=true&playerId=kaltura_player&entry_id=1_1ksfwja3&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[hotspots.plugin]=1&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_k1vhj9q5" width="304" height="231" allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-downloads allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Example 1.2" style="position:absolute;top:0;left:0;width:100%;height:100%;border:0"></iframe></div></div>

:::

::::{#exm-data-float chapter=1 description="Floating-point numbers" type=üíª}
if you enter an integer, it is interpreted as an `int`:
```{python}
# This is an integer (int type)
print(3, "is a", type(3))
```

To get the floating-point version, you add a decimal point:
```{python}
# This is a real number (float type)
print(3.0, "is a", type(3.0))
```

You can also use scientific notation:
```{python}
print(6.02e23, "is Avogadro's number")
print(6.62607e-34, "is Planck's constant in Joule-seconds")
```

There are also explicit converter functions. The conversion of an `int` to a `float` is generally exact:
```{python}
# Convert int to float (generally no change to numerical value)
print( "float(3) creates",float(3) )
```

But the conversion of `int` to `float` truncates the number, which can cause subtle bugs:
```{python}
# Truncate float to int
print( "int(3.14) creates", int(3.14) )
```

Because operations on floats are not exact, results can be surprising:
```{python}
print(0.2 - 0.1 == 0.1)    # as expected
print(3.1 - 3.0 == 0.1)    # uh-oh
```

The Numpy function `isclose` is a safer way to compare floats:
```{python}
import numpy as np
print( np.isclose(3.1 - 3.0, 0.1) )
```

::::

::: {.callout-warning}
Be careful about comparing floating-point values. Exact comparisons may fail due to rounding errors.
:::

### Inf and NaN

There are two additional quasi-numerical `float` values to be aware of as well.

::: {.callout-important}
For numerical work in Python, the NumPy package indispensible. We will use it often, and it is also loaded and used by most other scientifically oriented packages.
:::

The value `inf` in NumPy stands for infinity. 

:::{.column-margin}
<div style="max-width:304px"><div style="position:relative;padding-bottom:75.986842105263%"><iframe id="kaltura_player" src="https://cdnapisec.kaltura.com/p/2358381/sp/235838100/embedIframeJs/uiconf_id/43030021/partner_id/2358381?iframeembed=true&playerId=kaltura_player&entry_id=1_nyqbc6h9&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[hotspots.plugin]=1&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_8zmeafud" width="304" height="231" allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-downloads allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Example 1.3" style="position:absolute;top:0;left:0;width:100%;height:100%;border:0"></iframe></div></div>

:::

:::{.callout-warning}
By definition, every operation that involves a `NaN` value results in a `NaN`. 
:::

::::{#exm-data-inf-nan chapter=1 description="Infinity and NaN" type=üíª}
Infinity is greater than every number, and some arithmetic operations with infinity are well defined:

```{python}
import numpy as np
print( "(np.inf + 5) is", np.inf + 5 )
print( "(np.inf + np.inf) is", np.inf + np.inf )
print( "(5 - np.inf) is", 5 - np.inf )
```

However, in calculus you learned that some expressions with infinity are considered to be undefined without additional information (e.g., L'H√¥pital's Rule):

```{python}
print( "np.inf / np.inf is", np.inf / np.inf )
```

The result `nan` above stands for *Not a Number*. It is the result of indeterminate arithmetic operations, like $\infty/\infty$ and $\infty - \infty$. It is also used sometimes as a placeholder for missing data.

One notorious trap of using NaN is that `nan==nan` is not `True`!
```{python}
print( "np.nan == np.nan is", np.nan == np.nan )
```

Instead, you should use `np.isnan` to check for `NaN` values:
```{python}
print( "np.isnan(np.nan) is", np.isnan(np.nan) )
```

::::

### Dates and times

Handling times and dates can be tricky. Aside from headaches such as time zones and leap years, there are many different ways people and machines represent dates, and with varying amounts of precision. Python has its own inbuilt system for handling dates and times, but we will show the facilities provided by the NumPy package, which is more comprehensive.

There are two basic types:

::::{#def-data-time}
A **datetime** is a representation of an instant in time. A **time delta** is a representation of a duration; i.e., a difference between two datetimes.
::::

::: {.callout-important}
Native Python uses a `datetime` type, while NumPy uses `datetime64`.
:::

::::{#exm-data-datetime chapter=1 description="Dates and times in NumPy" type=üíª}
You can use many natural date formats within strings:
```{python}
import numpy as np
np.datetime64("2020-01-17")    # YYYY-MM-DD 
np.datetime64("1969-07-20T20:17")    # YYYY-MM-DDThh:mm
```

```{python}
# Current date and time, down to the second
np.datetime64("now")
```

A time delta in NumPy indicates its units (i. e., its granularity).

```{python}
np.datetime64("1969-07-20T20:17") - np.datetime64("today")
```

::::

## Vectors

Most interesting phenomena are characterized and influenced by more than one factor. Collections of values therefore play a central role in data science. The workhorse type for collections in base Python is the list. However, we're going to need some more powerful metaphors and tools as well, beginning with vectors.

::::{#def-data-vector}
A **vector** is a collection of values called **elements**, all of the same type, indexed by consecutive integers.
::::

::: {.callout-important}
In math, vector indexes usually begin with 1. In Python, they begin with 0. 
:::

A vector with $n$ elements is often referred to as an $n$-vector, and we say that $n$ is the **length** of the vector. In math we often use $\real^n$ to denote the set of all $n$-vectors with real-valued elements.

:::{.column-margin}
<div style="max-width:304px"><div style="position:relative;padding-bottom:75.986842105263%"><iframe id="kaltura_player" src="https://cdnapisec.kaltura.com/p/2358381/sp/235838100/embedIframeJs/uiconf_id/43030021/partner_id/2358381?iframeembed=true&playerId=kaltura_player&entry_id=1_g0hda6xi&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[hotspots.plugin]=1&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_tryruqu5" width="304" height="231" allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-downloads allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Example 1.5" style="position:absolute;top:0;left:0;width:100%;height:100%;border:0"></iframe></div></div>

:::

::::{#exm-data-vector chapter=1 description="Vectors in Python" type=üíª}
The usual way to work with vectors in Python is through NumPy:

```{python}
import numpy as np

x = np.array( [1, 2, 3, 4, 5] )
x
```


A vector has a data type for its elements:

```{python}
x.dtype
```

Any float values in the vector cause the data type of the entire vector to be `float`:

```{python}
y = np.array( [1.0, 2, 3, 4, 5] )
y.dtype
```

Use `len` to determine the length of a vector:

```{python}
len(x)
```

You can create a special type of vector called a *range* that has equally spaced elements:

```{python}
np.arange(0, 5)
```

```{python}
np.arange(1, 3, 0.5)
```

The syntax here is `(start,stop,step)`. 

::: {.callout-caution}
In base Python and in NumPy, the last element of a range is omitted. This is guaranteed to cause confusion if you are used to just about any other computer language.
:::

There are functions for creating vectors of ones and zeros:

```{python}
print(np.ones(5))
print(np.zeros(4))
```

::::

### Element access
The elements of a vector can be accessed directly using square brackets notation. 

:::{.column-margin}
<div style="max-width:304px"><div style="position:relative;padding-bottom:75.986842105263%"><iframe id="kaltura_player" src="https://cdnapisec.kaltura.com/p/2358381/sp/235838100/embedIframeJs/uiconf_id/43030021/partner_id/2358381?iframeembed=true&playerId=kaltura_player&entry_id=1_f06t1pv6&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[hotspots.plugin]=1&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_lch4gsfq" width="304" height="231" allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-downloads allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Example 1.6" style="position:absolute;top:0;left:0;width:100%;height:100%;border:0"></iframe></div></div>

:::

::::{#exm-data-access chapter=1 description="Accessing vector elements" type=üíª}
Use square brackets to refer to an element of a vector, remembering that the first element has index 0:

```{python}
x[0]
```

```{python}
x[4]
```

Negative values for the index are counted from the end. The last element of a vector always has index `-1`, and more-negative values move backward through the elements:

```{python}
x[-1]
```

```{python}
x[-3]
```

```{python}
x[-len(x)]
```

Element references can also be on the left side of an assignment:

```{python}
x[2] = -3
x
```

Note, however, that once the data type of a vector is set, it can't be changed:

```{python}
x[0] = 1.234
x    # float was truncated to int, without warning!!!
```

You can also use a list in square brackets to access multiple elements at once:

```{python}
x[ [0, 2, 4] ]
```

The result of a list reference is a new vector, not a number. Note the difference here:

```{python}
x[0]
```

```{python}
x[ [0] ]
```

::::

### Slicing

You can also access multiple elements of a vector by using a list or range as the index. In the latter case, this is called **slicing**.

:::{.callout-warning}
As with ranges in base Python, the last element of a slice range is omitted. This causes many headaches and bugs.
:::

:::{.column-margin}
<div style="max-width:304px"><div style="position:relative;padding-bottom:75.986842105263%"><iframe id="kaltura_player" src="https://cdnapisec.kaltura.com/p/2358381/sp/235838100/embedIframeJs/uiconf_id/43030021/partner_id/2358381?iframeembed=true&playerId=kaltura_player&entry_id=1_veepu3vo&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[hotspots.plugin]=1&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_j1bs7x12" width="304" height="231" allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-downloads allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Example 1.7" style="position:absolute;top:0;left:0;width:100%;height:100%;border:0"></iframe></div></div>

:::

::::{#exm-data-slice chapter=1 description="Slicing vectors" type=üíª}
The syntax of a slice is `start:stop`. 

```{python}
print(x[0:3])
print(x[-3:-1])
```

If you want to use a range that skips over elements, you can use a third argument in the form `start:stop:step`:

```{python}
x[0:2:5]
```

When the `start` of the range is omitted, it means "from the beginning", and when `stop` is omitted, it means "through to the end." Hence, `[:k]` means "first $k$ elements" and `[-k:]` means "last $k$ elements":

```{python}
x[:3]
```

```{python}
x[-3:]
```

And we also have this idiom:

```{python}
x[::-1]   # reverse the vector
```

NumPy will happily allow you to reference invalid indexes. It will just return as much as is available without warning or error:

```{python}
x[:10]
```

::::

![](_media/memes/slicing.jpg){width=50%}

## Arrays

A vector is a special case of a more general construct.

:::{#def-data-array}
An **array** is a collection of values called **elements**, all of the same type, indexed by one or more sets of consecutive integers. The number of indexes needed to specify a value is the **dimension** of the array.

:::

:::{.callout-tip}
A dimension is called an `axis` in NumPy and related packages.

:::

:::{.callout-note}
The term **matrix** is often used simply to mean a 2D array. Technically, though, a matrix should have only numerical values, and matrices obey certain properties that make them important mathematical objects. These properties and their consequences are studied in linear algebra.

:::

For us, arrays will mostly be the results of importing or working on data. But it's occasionally useful to know how to build them from scratch.

:::{.column-margin}
<div style="max-width:304px"><div style="position:relative;padding-bottom:75.986842105263%"><iframe id="kaltura_player" src="https://cdnapisec.kaltura.com/p/2358381/sp/235838100/embedIframeJs/uiconf_id/43030021/partner_id/2358381?iframeembed=true&playerId=kaltura_player&entry_id=1_xqgr0oc8&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[hotspots.plugin]=1&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_ugy7sg7t" width="304" height="231" allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-downloads allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Example 1.8" style="position:absolute;top:0;left:0;width:100%;height:100%;border:0"></iframe></div></div>

:::

::::{#exm-data-array chapter=1 description="Arrays in Python" type=üíª}
One way to construct an array is by a **list comprehension**:

```{python}
A = np.array([ [j-i for j in range(6)] for i in range(4) ])
A
```

The `shape` of an array is what we would often call the *size*:

```{python}
A.shape
```

There is no difference between a vector and a 1D array:

```{python}
x.shape
```

There is also no difference between a 2D array and a vector of vectors giving the rows of the array.

```{python}
R = np.array( [ [1, 2, 3], [4, 5, 6] ])
R
```

Here are some other common ways to construct arrays.

```{python}
np.ones(5)
```

```{python}
np.zeros( (3, 6) )
```

```{python}
np.repeat(np.pi, 3)
```

You can also stack arrays vertically or horizontally to create new arrays.

```{python}
np.hstack( ( np.ones((2, 2)), np.zeros((2, 3)) ) )
```

```{python}
np.vstack( (range(5), range(5, 0, -1)) )
```

::::

### Indexing and slicing

One way to think about a 2D array is a vector of vector rows of the same length. That idea is reflected in NumPy syntax.

:::{.column-margin}
<div style="max-width:304px"><div style="position:relative;padding-bottom:75.986842105263%"><iframe id="kaltura_player" src="https://cdnapisec.kaltura.com/p/2358381/sp/235838100/embedIframeJs/uiconf_id/43030021/partner_id/2358381?iframeembed=true&playerId=kaltura_player&entry_id=1_nhk4pa65&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[hotspots.plugin]=1&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_ns9347ku" width="304" height="231" allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-downloads allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Example 1.9" style="position:absolute;top:0;left:0;width:100%;height:100%;border:0"></iframe></div></div>

:::

::::{#exm-data-array-index chapter=1 description="Indexing arrays" type=üíª}
We can use successive brackets to refer to an element, row then column:

```{python}
R[1][2]    # second row, third column
```

It's equivalent, and typically more convenient, to use a single bracket set with indexes separated by commas:

```{python}
R[1, 2]    # second row, third column
```

You can use slicing ranges in each dimension individually.

```{python}
R[:1, -2:]    # first row, last two columns
```

The result above is another 2D array. Note how this result is subtly different:

```{python}
R[0, -2:]
```

Because we accessed an individual row, not a slice, the result is one dimension lower---a vector. Finally, a `:` in one slice position means to keep everything in that dimension.

```{python}
A[:, :2]    # all rows, first 2 columns
```

::::

### Reductions

A common task is to **reduce** an array along one dimension, called an *axis* in numpy, resulting in an array of one less dimension.

:::{.column-margin}
<div style="max-width:304px"><div style="position:relative;padding-bottom:75.986842105263%"><iframe id="kaltura_player" src="https://cdnapisec.kaltura.com/p/2358381/sp/235838100/embedIframeJs/uiconf_id/43030021/partner_id/2358381?iframeembed=true&playerId=kaltura_player&entry_id=1_sb1cwatu&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[hotspots.plugin]=1&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_vnc91q62" width="304" height="231" allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-downloads allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Example 1.10" style="position:absolute;top:0;left:0;width:100%;height:100%;border:0"></iframe></div></div>

:::

::::{#exm-data-array-reduce chapter=1 description="Array reductions" type=üíª}
The first dimension of an array is axis number 0, the second is axis number 1, etc. 

```{python}
A
```

```{python}
np.sum(A, axis=0)    # sum along the rows
```

Even when we sum along the column dimension, `axis=1`, the result is a vector that we would interpret as a row, not a column.

```{python}
np.sum(A, axis=1)    # sum along the columns
```

If you don't specify an axis, the reduction occurs over all dimensions at once, resulting in a single number.

```{python}
np.sum(A)
```

::::

You can also do reductions with `np.max`, `np.min`, `np.mean`, etc.

![](_media/memes/reduced.jpg){width=50%}

## Qualitative data

A qualitative value is one that is not quantitative. There are numerous types, but we will consider only a few of them here. Ultimately, we need to be able to represent qualitative data in a quantitative way for use in algorithms.

### Categorical

:::{#def-data-categorical}
**Categorical** data has values drawn from a finite set $S$ of categories. If the members of $S$ support meaningful ordering comparisons, then the data is **ordinal**; otherwise, it is **nominal**.
:::

::::{#exm-data-categorical chapter=1 description="Ordinal data" type=‚úçÔ∏è}
Examples of ordinal categorical data:

* Seat classes on a commercial airplane (e.g., economy, business, first)
* Letters of the alphabet

Examples of nominal categorical data:

* Yes/No responses
* Marital status
* Make of a car

There are nuanced cases. For instance, letter grades are themselves ordinal categorical data. However, schools convert them to discrete quantitative data and then compute a continuous quantitative GPA.

::::

One way to quantify ordinal categorical data is to assign integer values to the categories in a manner that preserves ordering. This approach can be suspect, though, when it comes to operations such as averaging or computing a distance between values. 

#### Dummy variables 

Another means of quantifying categorical data is called **dummy variables** in classical statistics and **one-hot encoding** in much of machine learning. Suppose a variable $x$ has values in a category set that has $m$ members, i. e., $S = \{c_1,\ldots,c_m\}$. There are two ways to replace the values with dummy variables.

1. Introduce $m$ variables $x_1,\ldots,x_m$, where for a given categorical value $v$ we have 

$$
x_i = \begin{cases} 1, & v = c_i, \\ 0, & v \neq c_i. \end{cases}
$$

2. Introduce only $m-1$ variables, leaving out $x_m$. If $x_1=x_2=\ldots=x_{m-1}=0$, then we know that the value is $c_m$. (This variant is important in statistics because otherwise, $x_m$ has to be correlated with the other $x_i$.) 

::::{#exm-data-dummy chapter=1 description="Dummy variables" type=‚úçÔ∏è}
Suppose that the *stooge* variable can take the values `Moe`, `Larry`, `Curly`, or `Shemp`, and we have the dataset

```{python}
["Curly", "Moe", "Curly", "Shemp"]
```

If we use 4 dummy variables, the data would be replaced by the array

```{python}
[ [0, 0, 1, 0], [1, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1] ]
```

If we use only 3 dummy variables, we would get

```{python}
[ [0, 0, 1], [1, 0, 0], [0, 0, 1], [0, 0, 0] ]
```

::::

### Text 

Text is a ubiquitous data source. One way to quantify text is to use a dictionary of interesting keywords $w_1,\ldots,w_n$. Given a collection of documents $d_1,\ldots,d_m$, we can define an $m\times n$ **document--term matrix** $T$ by letting $T_{ij}$ be the number of times term $j$ appears in document $i$. 

### Images

The most straightforward way to represent an image is as a 3D array of values representing intensities representing of red, green and blue in each pixel. Sometimes it might be preferable to represent the image by a vector of statistics about these values, or by presence or absence of detected objects, etc.

## Working in pandas

The most popular Python package for manipulating and analyzing data is [pandas](https:pandas.pydata.org). We will use the paradigm it presents, which is fairly well understood throughout data science.

### Series

::::{#def-series}
A **series** is a vector that is indexed by a finite ordered set. 

::::

In NumPy, we always index vectors by absolute position. In pandas, the elements still have an underlying ordering, but we can index them by anything, including strings. Since names are more memorable and intuitive than arbitrary integers, using them makes code easier to write, read, and debug. 

::::{#exm-data-series chapter=1 description="Series" type=‚úçÔ∏è}
Some data that can be viewed as series:

* The length, width, and height of a box can be expressed as a 3-vector of positive real numbers. If we index the vector by the names of the measurements, it becomes a series.
* The number of steps taken by an individual over the course of a week can be expressed as a 7-vector of nonnegative integers. We could index it by the integers 1--7, or in a series by the names of the days of the week.
* The bid prices of a stock at the end of each trading day can be represented as a *time series*, in which the index is drawn from timestamps. 
::::

::::{#exm-data-series-create chapter=1 description="Series in pandas" type=üíª}
Here is a small pandas series. Note that we give the values first and then the index:

```{python}
import pandas as pd

names = ["Marge", "Homer", "Bart", "Lisa", "Maggie"]
months = pd.Series( ["March", "May", "February", "May", "January"], index=names)
months
```

We can access the values by choosing a name in the index:
```{python}
months["Lisa"]
```

If we access multiple values, we get a series that is a subset of the original:
```{python}
months[ ["Homer", "Marge"] ]
```

We can also use the `iloc` property to access the underlying vector by NumPy slicing:
```{python}
months.iloc[-3:]
```

Here is a series of years based on the same index:
```{python}
years = pd.Series([1955, 1956, 1979, 1981, 1988], index=names)
years
```

We can also start with the series and separate it into a vector of values and its index:

```{python}
print("Values:")
print(years.values)
print("\nIndex:")
print(years.index)
```

::::

@tbl-data-series lists some common operations on pandas series. There is an [exhaustive list](https://pandas.pydata.org/docs/reference/series.html) in the pandas documentation.

| Description                  | Syntax                   | Result         |
| :--------------------------- | :----------------------- | :------------- |
| First or last entries        | `s.head()`, `s.tail()`   | Series         |
| Length                       | `len(s)`                 | integer        |
| All of the values            | `s.values`               | array          |
| Convert values to list       | `list(s)`                | list           |
| Index                        | `s.index`                | Index          |
| Unique values                | `s.unique()`             | array          |
| Appearance frequencies       | `s.value_counts()`       | Series         |
| Extreme values               | `s.min()`, `s.max()`     | number         |
| Sum                          | `s.sum()`                | number         |
| Comparison                   | `s > 1`,  `s=="foo"`     | boolean Series |
| Locate missing               | `s.isna()`               | boolean Series |
| Arithmetic                   | `s + 1`,  `s * t`        | Series         |
| Delete one or more rows      | `s.drop()`               | Series         |

: Operations on pandas series {#tbl-data-series}

::: {.callout-caution}
As always in Python, you need to pay attention to the difference between applying a function, like `foo(bar)`, accessing a property, like `foo.bar`, and calling an object method, `foo.bar()`. Extra or missing parentheses groups can cause errors.
:::

::::{#exm-data-series-operate chapter=1 description="Operations on series" type=üíª}
We continue with the definitions in @exm-data-series-create. Here are all the unique values of the months:

```{python}
months.unique()
```

Here are the frequencies of their appearance:

```{python}
months.value_counts()
```

Note that we can do a logical comparison and get a series of boolean values:

```{python}
months == "May"
```

Since the years are numerical, we can do arithmetic operations on them:

```{python}
print("Minimum year is", years.min(), "and maximum year is", years.max())
print("The sum of the years is", years.sum())
```

::::

### Data frames

::::{#def-data-frame}
A **data frame** is a collection of series that all share the same index set. 

::::

Essentially, a data frame is a 2D array with a common index for the rows, where the constituent series are the columns of the array. Those columns can also be indexed by names (strings). Since names are much more memorable and intuitive than arbitrarily assigned integers, data frames make code easier to write, read, and reason about.

::: {.callout-tip}
Curly braces `{ }` are used to construct a dictionary in Python.

:::

::::{#exm-data-frames-create chapter=1 description="Series and frames in pandas" type=üíª}
We continue with the definitions of `months` and `years` in @exm-data-series-create, and use a dictionary to specify the columns of a data frame:

```{python}
simpsons = pd.DataFrame( {"month": months, "date":  [19, 12, 23, 9, 14], "year": years } )
simpsons
```

Notice above that the *date* column was given as just a list of numbers; the index for it was inherited from the `months` series.

If we give the name of a column as an index into the frame, we get back a series for that column:

```{python}
simpsons["year"]
```

If we give a list of column names, we get back a data frame with just those columns:

```{python}
simpsons[ ["month", "date"] ]
```

We can even index a nonexistent column on the left side of an assignment, and pandas will create it for us:

```{python}
simpsons["weekday"] = ["Saturday", "Saturday", "Friday", "Saturday", "Thursday"]
simpsons
```

We can access a row by using brackets with the `loc` property of the frame, getting a series indexed by the column names of the frame:
```{python}
simpsons.loc["Maggie"]
```

We are also free to strip away the index and get an ordinary array:
```{python}
simpsons.to_numpy()
```

Another way to create a data frame is to give a list of rows, plus (optionally) the index and the names of the columns:

```{python}
pd.DataFrame( 
    [ ("white", 5), ("brown", 9), ("pink", 8) ], 
    columns=["Color", "Rating"],
    index=["vanilla", "chocolate", "strawberry"]
    )
```

::::

:::{.column-margin}
<div style="max-width:304px"><div style="position:relative;padding-bottom:75.986842105263%"><iframe id="kaltura_player" src="https://cdnapisec.kaltura.com/p/2358381/sp/235838100/embedIframeJs/uiconf_id/43030021/partner_id/2358381?iframeembed=true&playerId=kaltura_player&entry_id=1_t6nb4pa3&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[hotspots.plugin]=1&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_oqa2u2y8" width="304" height="231" allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-downloads allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Example 1.14" style="position:absolute;top:0;left:0;width:100%;height:100%;border:0"></iframe></div></div>

:::

![](_media/memes/rainbow.jpg){width=50%}


:::{.column-margin}
<div style="max-width:304px"><div style="position:relative;padding-bottom:75.986842105263%"><iframe id="kaltura_player" src="https://cdnapisec.kaltura.com/p/2358381/sp/235838100/embedIframeJs/uiconf_id/43030021/partner_id/2358381?iframeembed=true&playerId=kaltura_player&entry_id=1_44v37coz&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[hotspots.plugin]=1&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_e9add9y2" width="304" height="231" allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-downloads allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Example 1.15" style="position:absolute;top:0;left:0;width:100%;height:100%;border:0"></iframe></div></div>

:::

### Common operations


@tbl-data-frames shows common operations specific to a data frame. But since the columns are series, the operations in @tbl-data-series can be applied too, and they will act columnwise. 


| Description                | Syntax                   | Result              |
| :------------------------- | :----------------------- | :------------------ |
| Summary information        | `df.info()`, `df.describe()` | DataFrame           |
| First or last row(s)       | `df.head()`, `df.tail()` | DataFrame           |
| Number of rows             | `len(df)`                | integer             |
| Number of rows and columns | `df.shape`               | tuple               |
| Row index                  | `df.index`               | Index               |
| Column names               | `list(df)`               | list                |
| Column names               | `df.columns`             | Index               |
| Access by column name(s)   | `df["name"]`, `df[["col1", "col2"]]`     | Series or DataFrame |
| Access by index/name       | `df.loc[rows, "name"]`   | (varies)            |
| Access by position         | `df.iloc[i, j]`          | (varies)            |
| Delete a column            | `df.drop(name, axis=1)`  | DataFrame           |

: Operations on pandas data frames {#tbl-data-frames}

It takes a lot of space to demonstrate all the ways in which these can be used, as is done in the [pandas user guide](https://pandas.pydata.org/docs/user_guide/basics.html). There is also an [exhaustive list](https://pandas.pydata.org/docs/reference/frame.html) of them in the pandas documentation.

### Categorical data in pandas

Pandas has many facilities for dealing with categorical variables.

:::{.column-margin}
{{< video https://www.dropbox.com/s/fjf4gj8bj5hwvwm/Section1_5_c.mp4?raw=1 >}}

:::

::::{#exm-data-ordinal chapter=1 description="Ordinal data" type=üíª}
Here is a [dataset](https://ggplot2.tidyverse.org/reference/diamonds.html) about features and prices of diamonds:

```{python}
import seaborn as sns
diamonds = sns.load_dataset("diamonds")
diamonds.head()
```

As you can see above, some of the features (cut, color, clarity) have string designations. We could convert *clarity*, for example, to a categorical variable like so: 

```{python}
pd.Categorical(diamonds["clarity"])
```

However, these values actually have a specific ordering in this context, and that is lost in the nominal variable above. We can fix that by specifying the ordering when we create the categorical variable:

```{python}
clarities = ["I1", "SI2", "SI1", "VS2", "VS1", "VVS2", "VVS1", "IF"]
pd.Categorical(diamonds["clarity"], categories=clarities, ordered=True)
```

Often we want to replace ordered categories with integers:

```{python}
cl_num = pd.Categorical(diamonds["clarity"], categories=clarities, ordered=True)
diamonds["clarity"] = cl_num.codes
diamonds.head()
```

In such cases, it's more direct to use string replacement:

```{python}
cuts = ["Fair", "Good", "Very Good", "Premium", "Ideal"]
diamonds["cut"] = diamonds["cut"].replace(
    cuts,              # to be replaced
    range(1, 6),       # replacements
)
diamonds.head()
```

::::

:::{.column-margin}
<div style="max-width:304px"><div style="position:relative;padding-bottom:75.986842105263%"><iframe id="kaltura_player" src="https://cdnapisec.kaltura.com/p/2358381/sp/235838100/embedIframeJs/uiconf_id/43030021/partner_id/2358381?iframeembed=true&playerId=kaltura_player&entry_id=1_wh19lhvn&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[hotspots.plugin]=1&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_z05q0byw" width="304" height="231" allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-downloads allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Example 1.16" style="position:absolute;top:0;left:0;width:100%;height:100%;border:0"></iframe></div></div>

:::

A common need is to convert a categorical variable to dummy variables. Pandas makes that a one-liner.

::::{#exm-data-chess chapter=1 description="Categorical data in pandas" type=üíª}
Here is a vector of chess pieces at the start of a game:

```{python}
pieces = pd.Series( [
    "pawn", "pawn", "pawn", "pawn", "pawn", "pawn", "pawn", "pawn",
    "knight", "bishop", "rook", "knight", "bishop", "rook",
    "queen", "king"
] )
```

We can use pandas to convert this variable to dummy variables:

```{python}
pd.get_dummies(pieces)
```

We can also use the encoding variant in which one of the categories is left out:

```{python}
pd.get_dummies(pieces, drop_first=True).head(6)
```

::::

### Loading from files 

Datasets can be presented in many forms. The simplest and most universal are *comma-separated value* (CSV) files. Such files can be read by pandas locally or over the web.

::::{#exm-data-read chapter=1 description="Importing CSV data" type=üíª}
The pandas function we use to load a dataset from CSV is `read_csv`. Here we use it to read a file that is available over the web:

```{python}
ads = pd.read_csv("https://raw.githubusercontent.com/tobydriscoll/ds1book/master/advertising.csv")
ads.head(6)    # show the first 6 rows
```

Note above that we used `head(6)` to see just the first 6 rows.

It's a good idea to check what you've just loaded:
```{python}
ads.info()   
```

::::

:::{.callout-tip}
Here is one thing to watch for when loading numerical data. If a column has anything non-numeric in it, like "N/A" or "unknown", pandas will load that column as a string. 

:::

:::{.column-margin}
<div style="max-width:304px"><div style="position:relative;padding-bottom:75.986842105263%"><iframe id="kaltura_player" src="https://cdnapisec.kaltura.com/p/2358381/sp/235838100/embedIframeJs/uiconf_id/43030021/partner_id/2358381?iframeembed=true&playerId=kaltura_player&entry_id=1_mrq75g07&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[hotspots.plugin]=1&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_dc029nzp" width="304" height="231" allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-downloads allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Example 1.18" style="position:absolute;top:0;left:0;width:100%;height:100%;border:0"></iframe></div></div>

:::

:::{.callout-tip}
While it's possible to import datasets directly from the web, links change and disappear frequently. If storing the dataset locally is not a problem, you may want to download your own copy before working on it.

:::

It's also possible to import data from most other general-purpose formats you might encounter, such as Excel spreadsheets (though possibly requiring one-time installation of additional libraries). There are many functions starting with `pd.read_` showing the formats pandas understands.

## Selecting rows and columns

In a data frame, we access columns by giving a string name, or a list of names, in square brackets. We can access a row by the `loc` property with an index value, or `iloc` with an absolute row number starting from zero. 

::::{#exm-data-row-iloc chapter=1 description="iloc for rows in a frame" type=üíª}
Here's a local file that contains daily weather summaries from Newark, Delaware:

```{python}
weather = pd.read_csv("_datasets/ghcn_newark.csv")
weather.head()
```

There are lots of columns here. We will work with a small subset of them:

```{python}
columns = ["DATE", "PRCP", "SNOW", "TMAX", "TMIN"]
weather = weather[columns]
weather.head()
```

The first row has absolute position zero:

```{python}
weather.iloc[0]
```

The result above is a series, with the column names of the original data frame serving as the index. The following result is subtly different:

```{python}
weather.iloc[:1]
```

The slicing syntax `[:1]` means "the first 1 rows". The result is a one-row data frame---*not* a series. To access the last 4 rows, we can use a negative index:

```{python}
weather.iloc[-4:]
```

::::

:::{.column-margin}
<div style="max-width:304px"><div style="position:relative;padding-bottom:75.986842105263%"><iframe id="kaltura_player" src="https://cdnapisec.kaltura.com/p/2358381/sp/235838100/embedIframeJs/uiconf_id/43030021/partner_id/2358381?iframeembed=true&playerId=kaltura_player&entry_id=1_q2pr26id&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[hotspots.plugin]=1&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_oflglmwo" width="304" height="231" allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-downloads allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Example 1.19" style="position:absolute;top:0;left:0;width:100%;height:100%;border:0"></iframe></div></div>

:::

In @exm-data-row-iloc, we did not specify an index for the data frame, so the row numbers were the index. If we give a data frame a different index, we can use `loc` to access rows by the index value.

::::{#exm-data-row-loc chapter=1 description="loc for rows in a frame" type=üíª}
A natural candidate for an index in the weather data is the *DATE* column. This can be specified when the file is read, but here we do it after the fact:

```{python}
dated_weather = weather.set_index("DATE")
dated_weather.head()
```

Notice above that the leftmost column of `dated_weather` is the index, which still has the column name *DATE*. We can access a row by giving a date string to `loc`:

```{python}
dated_weather.loc["1979-03-28"]
```

We can extract a row and column simultaneously by giving both to `loc`:

```{python}
dated_weather.loc["1979-03-28", "TMAX"]
```

When the index is a date, as is the case here, we can even use a range of dates:

```{python}
dated_weather.loc["1979-03-01":"1979-03-06"]
```

::::

:::{.column-margin}
<div style="max-width:304px"><div style="position:relative;padding-bottom:75.986842105263%"><iframe id="kaltura_player" src="https://cdnapisec.kaltura.com/p/2358381/sp/235838100/embedIframeJs/uiconf_id/43030021/partner_id/2358381?iframeembed=true&playerId=kaltura_player&entry_id=1_19xrcnne&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[hotspots.plugin]=1&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_3xgggkkf" width="304" height="231" allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-downloads allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Example 1.20" style="position:absolute;top:0;left:0;width:100%;height:100%;border:0"></iframe></div></div>

:::

![](_media/memes/rows.jpg){width=40%}

Frequently we want to select rows from a data frame based on criteria applied to the data itself. We can use relational operators such as `>`, `<`, `==`, etc. to select rows based on the values in a column.

::::{#exm-data-row-select chapter=1 description="Selecting rows in a frame" type=üíª}
Here is how we can select all the rows in which the value of *PRCP* is greater than 1200:

```{python}
weather.loc[weather["PRCP"] > 1200]
```

There are two steps above. The expression inside the square brackets produces a series of Boolean values:

```{python}
is_prcp = (weather["PRCP"] > 1200)
is_prcp.head()
```

This series can be used to select rows with `loc`. Actually, it works without `loc` as well, because pandas knows it is a row selector:

```{python}
print("There are",is_prcp.sum(),"rows with PRCP > 1200.")
weather[is_prcp]
```

We can use logical operators `&` (AND), `|` (OR), and `~` (NOT) on these Boolean series in order to combine criteria:
```{python}
weather[(weather["TMAX"] < 0) & (weather["SNOW"] > 0)]
```

::::

:::{.column-margin}
<div style="max-width:304px"><div style="position:relative;padding-bottom:75.986842105263%"><iframe id="kaltura_player" src="https://cdnapisec.kaltura.com/p/2358381/sp/235838100/embedIframeJs/uiconf_id/43030021/partner_id/2358381?iframeembed=true&playerId=kaltura_player&entry_id=1_k1lb9pe7&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[hotspots.plugin]=1&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_hs13e0f9" width="304" height="231" allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-downloads allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Example 1.21" style="position:absolute;top:0;left:0;width:100%;height:100%;border:0"></iframe></div></div>

:::

::: {.callout-tip}
The pandas user guide has a handy [section on selections](https://pandas.pydata.org/docs/user_guide/10min.html?highlight=boolean#selection).

:::

::: {.callout-tip}
For practice with pandas fundamentals, try the [Kaggle course](https://www.kaggle.com/learn/pandas).

:::

## Combining data frames 

Sometimes you want to combine data from different sources. There are multiple ways to do this in pandas, depending on the structure of the data you want to combine and the result you want to receive.

### Concatenation

The `concat` function is used to stack frames or series on top of each other. 

::::{#exm-data-concat chapter=1 description="Concatenating data in pandas" type=üíª}
```{python}
birds = pd.DataFrame(
    {
        "Name": ["Eagles", "Crows", "Falcons"],
        "Predatory": [True, False, True],
        "Family": ["Accipitridae", "Corvidae", "Falconidae"],
        "Color": ["Brown", "Black", "Blue‚ÄìGray"]
    }
)
birds
```

```{python}
teams = pd.DataFrame(
    {
        "Name": ["Falcons", "Eagles", "Bears"],
        "Home": ["Atlanta", "Philadelphia", "Chicago"],
        "Color": ["Red", "Green", "Blue"]
    }
)
teams
```

```{python}
pd.concat([birds, teams])

```

::::

This operation is occasionally useful, but more often data frames should be joined horizontally. While that can be done with `concat`, it's better to learn the more flexible `merge` method in the next section.

### Merging data

The `merge` function is used to merge frames based on the values within the columns. Generically, each source frame can have a *key* column that is used to match up rows.

::::{#exm-data-merge chapter=1 description="Merging data in pandas" type=üíª}
Continuing with the data frames from @exm-data-concat:

```{python}
pd.merge(birds, teams, on="Name")
```

The `on` keyword specifies the column that is the key for the merge. In the above merge, the result is a frame with only the rows that have a common value in the `Name` column. That's called an **inner join**, which is the default. An alternative is an **outer join**, which includes all rows from both frames:

```{python}
pd.merge(birds, teams, on="Name", how="outer")
```

Note also above that the column `Color` that appeared in both of the source frames was renamed to `Color_x` and `Color_y` in the result, since otherwise there would be a conflict.

It's also possible to do a **left join** or a **right join**, which use one of the original frames as the basis for the result:

```{python}
print("Left merge:")
print(pd.merge(birds, teams, on="Name", how="left"))
print("\nRight merge:")
print(pd.merge(birds, teams, on="Name", how="right"))
```

::::

:::{.callout-note}
The difference between outer join and inner join is the same as the union and intersection of sets‚Äîthe sets here being the `"on"` column contents.

:::

::::{#exm-data-merge-weather chapter=1 description="Merging data" type=üíª}
Here we load in weather data for Newark, DE, being sure that the column representing the date is parsed as dates:

```{python}
weather = pd.read_csv("_datasets/ghcn_newark.csv", parse_dates=["DATE"])
weather = weather[["DATE", "PRCP", "SNOW", "TMAX", "TMIN"]]
weather.head()
```

Here is another data frame for the S&P 500 stock market index:
```{python}
sp500 = pd.read_csv("_datasets/SP500_daily.csv", parse_dates=["Date"])
sp500["Gain"] = sp500["Close/Last"] - sp500["Open"]
sp500.head()
```

Now we can merge the weather data with the stock data according to the date. Note that here, the key is named differently in the two frames:

```{python}
merged = pd.merge(sp500, weather, left_on="Date", right_on="DATE")
merged.head()
```

Since we did an inner join, only the rows with a common date in both frames are included:

```{python}
print("There are", len(sp500), "rows in the S&P 500 data.")
print("There are", len(weather), "rows in the weather data.")
print("There are", len(merged), "rows in the inner-merged data.")
```

If the key you want to merge on is the index column, the syntax of the merge changes a little. Here is an example:

```{python}
weather = weather.set_index("DATE")
weather.head()
```

```{python}
result = pd.merge(sp500, weather, left_on="Date", right_index=True)
result.head()
```

::::

## Data preparation

Raw data often needs to be manipulated into a useable format before algorithms can be applied. Preprocessing data so that it is suitable for machine analysis is known as **data wrangling**.

There are a number of frequently encountered tasks in data wrangling, including:

* **Cleaning**: Handling missing values, removing duplicates, and correcting errors.
* **Preprocessing**: Ensuring that numbers, dates, and strings are interpreted as desired.
* **Transforming**: Normalizing, scaling, and encoding data (e.g., defining dummy variables).

These are tasks that graphical and AI assistive tools can help with a great deal. When using such tools, have them generate code that reproduces its steps. That way, you have a definitive record of what was done and can reproduce or modify it later.

### Cleaning

One of the most commonly encountered snags found in real data sets are rows that have missing values. There is no universal way that such values are presented. A missing value may be indicated by a zero or nonsensical value, or with a string such as "n/a", or just an empty cell. Within Python, it might be natural to represent missing values as `None`, but that is not a valid value for a NumPy array. It's more flexible within pandas to use `np.nan`, which stands for "not a number". 

Most algorithms will fail went presented with missing values, so you must either remove or replace them.

removal
: The `dropna()` method removes all rows that have missing values. By default, it creates a new copy of the data frame, so you must assign the result to a variable. Alternatively, you can use the argument `inplace=True` to modify the original frame. When applying `dropna()`, you may want to limit its effect to a subset of columns by using the `subset` argument with a list of columns.

replacement
: Removing rows can lead to data loss. An alternative is **imputation**, which means replacing the missing values with a representative value. The `fillna()` method makes it easy to use the mean, median, or mode of the non-missing values in a column. But you should be cautious about imputation, because it can easily misrepresent the underlying data. At the very least, you need to document how many values have been changed.

::::{#exm-data-missing chapter=1 description="Handling missing values in pandas" type=üíª}
Here is a well-known demonstration data set often referred to as *Palmer Penguins*:

```{python}
import seaborn as sns
penguins = sns.load_dataset("penguins")
penguins.head()
```

Note above that the fourth row of the frame is missing measurements. We can discover how many such rows there are using `isna`, which creates a Boolean series:

```{python}
penguins.isna()
```

The total number of rows with missing data is  

```{python}
penguins.isna().sum()
```

To drop the rows with missing values, you can use `dropna()`:

```{python}
dropped = penguins.dropna()
print("Original has", len(penguins), "rows.")
print("After removals, there are", len(dropped), "rows.")
```

If you want to impute missing values, you can use `fillna()`. Here, for example, we replace missing values in any column with the mean of the column:

```{python}
filled = penguins.fillna(penguins.mean())
filled.head()
```

Note that only the numerical data columns were affected. The categorical column for *sex* was left alone.

::::

:::{.column-margin}
<div style="max-width:304px"><div style="position:relative;padding-bottom:75.986842105263%"><iframe id="kaltura_player" src="https://cdnapisec.kaltura.com/p/2358381/sp/235838100/embedIframeJs/uiconf_id/43030021/partner_id/2358381?iframeembed=true&playerId=kaltura_player&entry_id=1_uumcim3n&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[hotspots.plugin]=1&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_cs0thbt3" width="304" height="231" allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-downloads allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Example 1.23" style="position:absolute;top:0;left:0;width:100%;height:100%;border:0"></iframe></div></div>

:::

![](_media/memes/missing.jpg){width=40%}


### Preprocessing

A common pitfall is that data that seems numerical to you might be parsed as strings by pandas. This happens when there are non-numeric characters in the data, such as dollar signs or percent signs, and any row with such a character will cause the whole column to be interpreted as strings.

::::{#exm-data-loans chapter=1 description="Cleaning a data frame" type=üíª}
To demonstrate algorithms in later sections, we will be using a [dataset describing loans](https://www.kaggle.com/datasets/imsparsh/lending-club-loan-dataset-2007-2011) made on the crowdfunding site LendingClub. 

```{python}
loans = pd.read_csv("_datasets/loans.csv")
loans.head()
```

The `int_rate` column, which gives the interest rate on the loan, has been interpreted as strings due to the percent sign. We'd like to strip out those percent signs and convert the rest to numeric types. We can use the `str` property of the column to access string methods:

```{python}
int_rate = loans["int_rate"].str.strip('%')
```

Then, we can convert the result to numeric:

```{python}
loans["int_rate"] = pd.to_numeric( int_rate )
loans.head()
```

The *title* column contains strings that haphazardly formatted:

```{python}
loans["title"]
```

We might improve matters by converting everything in that column to lowercase:

```{python}
loans["title"] = loans["title"].str.lower()
loans.head()
```

Let's add a column for the percentage of the loan request that was eventually funded. This might be a useful feature for a learning model.

```{python}
loans["percent_funded"] = 100 * loans["funded_amnt"] / loans["loan_amnt"]
loans.head()
```

::::

:::{.callout-tip}
As you see above, we often end up with chains of methods separated by dots. Python works from the inside out, left to right, evaluating a sub-expression and then replacing it with the output for the next segment in the chain. We could write these as a sequence of separate lines having intermediate results assigned to variable names, but it's considered better style to chain them.

:::

:::{.column-margin}
<div style="max-width:304px"><div style="position:relative;padding-bottom:75.986842105263%"><iframe id="kaltura_player" src="https://cdnapisec.kaltura.com/p/2358381/sp/235838100/embedIframeJs/uiconf_id/43030021/partner_id/2358381?iframeembed=true&playerId=kaltura_player&entry_id=1_atu5pvx5&flashvars[streamerType]=auto&amp;flashvars[localizationCode]=en&amp;flashvars[sideBarContainer.plugin]=true&amp;flashvars[sideBarContainer.position]=left&amp;flashvars[sideBarContainer.clickToClose]=true&amp;flashvars[chapters.plugin]=true&amp;flashvars[chapters.layout]=vertical&amp;flashvars[chapters.thumbnailRotator]=false&amp;flashvars[streamSelector.plugin]=true&amp;flashvars[EmbedPlayer.SpinnerTarget]=videoHolder&amp;flashvars[dualScreen.plugin]=true&amp;flashvars[hotspots.plugin]=1&amp;flashvars[Kaltura.addCrossoriginToIframe]=true&amp;&wid=1_e6fttwyk" width="304" height="231" allowfullscreen webkitallowfullscreen mozAllowFullScreen allow="autoplay *; fullscreen *; encrypted-media *" sandbox="allow-downloads allow-forms allow-same-origin allow-scripts allow-top-navigation allow-pointer-lock allow-popups allow-modals allow-orientation-lock allow-popups-to-escape-sandbox allow-presentation allow-top-navigation-by-user-activation" frameborder="0" title="Example 1.22" style="position:absolute;top:0;left:0;width:100%;height:100%;border:0"></iframe></div></div>

:::



## Exercises {.unnumbered}

::::{#exr-data-types}
For each type of data, classify it as discrete quantitative, continuous quantitative, categorical, or other.

a) How many students are enrolled at a university
a) Your favorite day of the week
a) How many inches of rain fall at an airport during one day
a) Weight of a motor vehicle
a) Manufacturer of a motor vehicle
a) Text of all Yelp reviews for a restaurant
a) Star ratings from all Yelp reviews for a restaurant
a) Size of the living area of an apartment
a) DNA nucleotide sequence of a cell

::::

::::{#exr-data-vectors}
Give the length of each vector or series.

a. Morning waking times every day for a week
a. Number of siblings (max 12) for each student in a class of 30
a. Position and momentum of a roller coaster car
::::

::::{#exr-test-dummy}
Describe a scheme for creating dummy variables for the days of the week. Use your scheme to encode the vector:

``` 
[Tuesday, Sunday, Friday, Tuesday, Monday]
```

::::
